# üìò Lecture et √©criture de fichiers en Java

Java permet de manipuler des fichiers texte pour lire ou √©crire des donn√©es. Ces op√©rations sont essentielles pour la persistance des donn√©es, la configuration d'applications ou le traitement de fichiers externes.

## üîπ 1. Concepts de base

- Un **fichier** est une ressource externe contenant des donn√©es persistantes.
- En Java, on peut lire et √©crire des fichiers en utilisant les classes du package `java.io`.

## üîπ 2. √âcriture dans un fichier

### 2.1 Avec `FileWriter` seul

```java
import java.io.FileWriter;
import java.io.IOException;

public class EcritureFichier1 {
    public static void main(String[] args) {
        try {
            FileWriter writer = new FileWriter("ecriture1.txt");
            writer.write("Bonjour, monde!\n");
            writer.write("Bonjour, monde!\n");
            writer.close();
        } catch (IOException e) {
            System.out.println("Erreur lors de l'√©criture : " + e.getMessage());
        }
    }
}
```

**Points cl√©s :**

- `FileWriter` permet d'√©crire du texte (caract√®res) dans un fichier.
- Chaque appel √† `write()` envoie imm√©diatement les caract√®res au disque (ou presque).
- Si le fichier n'existe pas, il est cr√©√©. S'il existe, il est √©cras√©. Pour √©viter d'√©craser et ajouter du contenu (√† la fin), on sp√©cifie un second argument bbol√©en √† `vrai` lors de la cr√©ation : `new FileWriter("exemple.txt", true)`.
- Il faut toujours **fermer** le fichier avec `close()` pour lib√©rer les ressources.

#### Avantages de `FileWriter` seul

‚úÖ Simple √† utiliser  
‚úÖ Aucune configuration suppl√©mentaire  
‚úÖ Suffisant pour √©crire de petites quantit√©s de texte occasionnellement

#### Inconv√©nients de `FileWriter` seul

‚ùå Moins performant pour les √©critures r√©p√©t√©es (ex. dans une boucle) ‚Üí Chaque write() provoque potentiellement un acc√®s disque, ce qui est co√ªteux  
‚ùå Pas de gestion de buffer interne optimis√©e  
‚ùå Moins flexible pour g√©rer le formatage ou les sauts de ligne

---

### 2.2 Avec `BufferedWriter` et `FileWriter` (et syntaxe `try-with-resources`)

**REMARQUE** : La structure `try-with-resources` n√©cessite Java 7 ou plus.

```java
import java.io.*; // importation group√©e

public class EcritureFichier2 {
    public static void main(String[] args) {
        try (BufferedWriter ecrire = new BufferedWriter(new FileWriter("ecriture2.txt"))) {
            ecrire.write("Bonjour !");
            ecrire.newLine(); // Pour aller √† la ligne
            ecrire.write("Ceci est une ligne √©crite dans un fichier.");
        } catch (IOException e) {
            System.out.println("Erreur lors de l'√©criture dans le fichier : " + e.getMessage());
        }
    }
}
```

**Points cl√©s :**

- `BufferedWriter` enveloppe (`wrap`) un `FileWriter` et ajoute un **tampon** (*buffer*) en m√©moire.
- Les √©critures ne vont pas directement sur le disque, mais d'abord dans ce tampon.
- Le contenu est ensuite √©crit sur le disque en bloc, ce qui r√©duit les acc√®s physiques.

#### Avantages de `BufferedWriter` avec `FileWriter`

‚úÖ Performance accrue : le buffer limite les acc√®s disques  
‚úÖ Efficace dans les boucles (√©critures r√©p√©t√©es ou gros fichiers)  
‚úÖ M√©thodes pratiques (newLine(), etc.)  
‚úÖ Meilleur contr√¥le sur quand les donn√©es sont r√©ellement √©crites (flush())

#### Inconv√©nients de `BufferedWriter` avec `FileWriter`

‚ùå L√©g√®rement plus de code √† √©crire  
‚ùå N√©cessite d'appeler flush() ou de fermer correctement le flux pour vider le buffer  
‚ùå L√©g√®re consommation m√©moire additionnelle (tampon)  

---

### 2.3 Avec `PrintWriter`

```java
import java.io.*;

public class EcritureFichier3 {
    public static void main(String[] args) {
        try {
            PrintWriter ecrivain = new PrintWriter("ecriture3.txt");
            ecrivain.println("Bonjour !");
            ecrivain.printf("Valeur : %.2f%n", 3.14159);
            ecrivain.close();
        } catch (IOException e) {
            System.out.println("Erreur : " + e.getMessage());
        }
    }
}
```

#### Avantages de `PrintWriter`

‚úÖ Syntaxe intuitive, similaire √† `System.out`, ce qui facilite la transition pour les d√©butants.  
‚úÖ Dispose de m√©thodes comme `print()`, `println()`¬†, `printf()` pour √©crire du texte format√© facilement.  
‚úÖ Peut √©crire directement des `int`, `double`, `boolean`, etc., sans conversion manuelle.  
‚úÖ Peut √™tre combin√© avec `FileWriter` et `BufferedWriter` pour am√©liorer les performances ou g√©rer l'encodage

#### Inconv√©nients de `PrintWriter`

‚ùå Contrairement √† `BufferedWriter`, `PrintWriter` ne lance pas d'exception si une erreur d'√©criture survient (il faut v√©rifier avec `checkError()`).  
‚ùå Pour de tr√®s gros fichiers, `BufferedWriter` est souvent plus rapide gr√¢ce √† son tampon.  
‚ùå Si utilis√© seul avec un nom de fichier, il utilise l'encodage par d√©faut du syst√®me. Pour sp√©cifier l'encodage, il faut l'associer √† un `OutputStreamWriter`.  

---

## üîπ 3. Lecture d'un fichier

Voici 2 fa√ßons de lire un fichier **ligne par ligne** en Java.

### 3.1 Avec `FileReader` et `BufferedReader`

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LectureFichier1 {
    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader("lecture1.txt"));
            String ligne;
            while ((ligne = reader.readLine()) != null) {
                System.out.println(ligne);
            }
            reader.close();
        } catch (IOException e) {
            System.out.println("Erreur lors de la lecture : " + e.getMessage());
        }
    }
}
```

**Points cl√©s :**

- `BufferedReader` lit le fichier **ligne par ligne**.
- `readLine()` retourne `null` √† la fin du fichier.

#### Avantages de `FileReader` et `BufferedReader`

‚úÖ Lecture ligne par ligne pratique  
‚úÖ Efficace gr√¢ce au buffer  
‚úÖ Facile √† comprendre  

#### Inconv√©nients de `FileReader` et `BufferedReader`

‚ùå Un peu verbeux (plusieurs objets √† cr√©er)  

---

### 3.2 Avec `Scanner` et `File`

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class LectureFichier2 {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(new File("lecture2.txt"))) {
            while (sc.hasNextLine()) {
                String ligne = sc.nextLine();
                System.out.println(ligne);
            }
        } catch (FileNotFoundException e) {
            System.out.println("Fichier non trouv√©!");
        }
    }
}

```

#### Avantages de `Scanner` et `File`

‚úÖ Tr√®s simple √† comprendre  
‚úÖ Peut lire ligne par ligne ou mot par mot  
‚úÖ Parfait pour les d√©butants  

#### Inconv√©nients de `Scanner` et `File`

‚ùå Moins performant pour de gros fichiers  
‚ùå Moins de contr√¥le sur l'encodage (UTF-8, etc.)  

---

## üìä 4. Lecture de fichiers CSV

### üîπ Qu'est-ce qu'un fichier CSV ?

- CSV = **Comma-Separated Values** (valeurs s√©par√©es par des virgules).
- Chaque ligne repr√©sente un **enregistrement**.
- Chaque valeur est une **colonne**.

Exemple :

```text
Nom,√Çge,Ville
Alice,30,Shawinigan
Bob,25,Gatineau
```

### üîπ Lecture d'un fichier CSV (sans biblioth√®ques externes)

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LectureCSV {
    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader("donnees.csv"));
            String ligne;
            while ((ligne = reader.readLine()) != null) {
                String[] colonnes = ligne.split(",");
                System.out.println("Nom : " + colonnes[0]);
                System.out.println("√Çge : " + colonnes[1]);
                System.out.println("Ville : " + colonnes[2]);
                System.out.println("-----");
            }
            reader.close();
        } catch (IOException e) {
            System.out.println("Erreur : " + e.getMessage());
        }
    }
}
```

**Points cl√©s :**

- `split(",")` permet de s√©parer les valeurs.
- Attention aux **valeurs contenant des virgules** entre guillemets (cas avanc√©).
